/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useGubenProdContext, GubenProdContext } from "./gubenProdContext";
import type * as Fetcher from "./gubenProdFetcher";
import { gubenProdFetch } from "./gubenProdFetcher";
import type * as Schemas from "./gubenProdSchemas";

export type GetCategoriesQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: {
    [key: string]: any;
  };
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetCategoriesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetCategoriesVariables = {
  queryParams?: GetCategoriesQueryParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetCategories = (
  variables: GetCategoriesVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.CategoryListResponse,
    GetCategoriesError,
    undefined,
    {},
    GetCategoriesQueryParams,
    {}
  >({ url: "/categories", method: "get", ...variables, signal });

export const useGetCategories = <TData = Schemas.CategoryListResponse,>(
  variables: GetCategoriesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CategoryListResponse,
      GetCategoriesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<
    Schemas.CategoryListResponse,
    GetCategoriesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/categories",
      operationId: "getCategories",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCategories({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostCategoriesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostCategoriesVariables = {
  body: Schemas.CategoryRequest;
} & GubenProdContext["fetcherOptions"];

export const fetchPostCategories = (
  variables: PostCategoriesVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.CategoryResponse,
    PostCategoriesError,
    Schemas.CategoryRequest,
    {},
    {},
    {}
  >({ url: "/categories", method: "post", ...variables, signal });

export const usePostCategories = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CategoryResponse,
      PostCategoriesError,
      PostCategoriesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.CategoryResponse,
    PostCategoriesError,
    PostCategoriesVariables
  >({
    mutationFn: (variables: PostCategoriesVariables) =>
      fetchPostCategories({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCategoriesIdPathParams = {
  id: number;
};

export type GetCategoriesIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetCategoriesIdVariables = {
  pathParams: GetCategoriesIdPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetCategoriesId = (
  variables: GetCategoriesIdVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.CategoryResponse,
    GetCategoriesIdError,
    undefined,
    {},
    {},
    GetCategoriesIdPathParams
  >({ url: "/categories/{id}", method: "get", ...variables, signal });

export const useGetCategoriesId = <TData = Schemas.CategoryResponse,>(
  variables: GetCategoriesIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CategoryResponse,
      GetCategoriesIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<
    Schemas.CategoryResponse,
    GetCategoriesIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/categories/{id}",
      operationId: "getCategoriesId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCategoriesId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutCategoriesIdPathParams = {
  id: number;
};

export type PutCategoriesIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutCategoriesIdVariables = {
  body: Schemas.CategoryRequest;
  pathParams: PutCategoriesIdPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchPutCategoriesId = (
  variables: PutCategoriesIdVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.CategoryResponse,
    PutCategoriesIdError,
    Schemas.CategoryRequest,
    {},
    {},
    PutCategoriesIdPathParams
  >({ url: "/categories/{id}", method: "put", ...variables, signal });

export const usePutCategoriesId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CategoryResponse,
      PutCategoriesIdError,
      PutCategoriesIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.CategoryResponse,
    PutCategoriesIdError,
    PutCategoriesIdVariables
  >({
    mutationFn: (variables: PutCategoriesIdVariables) =>
      fetchPutCategoriesId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCategoriesIdPathParams = {
  id: number;
};

export type DeleteCategoriesIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteCategoriesIdVariables = {
  pathParams: DeleteCategoriesIdPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchDeleteCategoriesId = (
  variables: DeleteCategoriesIdVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    number,
    DeleteCategoriesIdError,
    undefined,
    {},
    {},
    DeleteCategoriesIdPathParams
  >({ url: "/categories/{id}", method: "delete", ...variables, signal });

export const useDeleteCategoriesId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteCategoriesIdError,
      DeleteCategoriesIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    number,
    DeleteCategoriesIdError,
    DeleteCategoriesIdVariables
  >({
    mutationFn: (variables: DeleteCategoriesIdVariables) =>
      fetchDeleteCategoriesId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetConfigQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: {
    [key: string]: any;
  };
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetConfigError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetConfigVariables = {
  queryParams?: GetConfigQueryParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetConfig = (
  variables: GetConfigVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.ConfigResponse,
    GetConfigError,
    undefined,
    {},
    GetConfigQueryParams,
    {}
  >({ url: "/config", method: "get", ...variables, signal });

export const useGetConfig = <TData = Schemas.ConfigResponse,>(
  variables: GetConfigVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ConfigResponse, GetConfigError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<Schemas.ConfigResponse, GetConfigError, TData>({
    queryKey: queryKeyFn({
      path: "/config",
      operationId: "getConfig",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetConfig({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutConfigError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutConfigVariables = {
  body: Schemas.ConfigRequest;
} & GubenProdContext["fetcherOptions"];

export const fetchPutConfig = (
  variables: PutConfigVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.ConfigResponse,
    PutConfigError,
    Schemas.ConfigRequest,
    {},
    {},
    {}
  >({ url: "/config", method: "put", ...variables, signal });

export const usePutConfig = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ConfigResponse,
      PutConfigError,
      PutConfigVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.ConfigResponse,
    PutConfigError,
    PutConfigVariables
  >({
    mutationFn: (variables: PutConfigVariables) =>
      fetchPutConfig({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteConfigError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteConfigVariables = GubenProdContext["fetcherOptions"];

export const fetchDeleteConfig = (
  variables: DeleteConfigVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<number, DeleteConfigError, undefined, {}, {}, {}>({
    url: "/config",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteConfig = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteConfigError,
      DeleteConfigVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    number,
    DeleteConfigError,
    DeleteConfigVariables
  >({
    mutationFn: (variables: DeleteConfigVariables) =>
      fetchDeleteConfig({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetEventsQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: {
    [key: string]: any;
  };
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetEventsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetEventsVariables = {
  queryParams?: GetEventsQueryParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetEvents = (
  variables: GetEventsVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.EventListResponse,
    GetEventsError,
    undefined,
    {},
    GetEventsQueryParams,
    {}
  >({ url: "/events", method: "get", ...variables, signal });

export const useGetEvents = <TData = Schemas.EventListResponse,>(
  variables: GetEventsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.EventListResponse,
      GetEventsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<Schemas.EventListResponse, GetEventsError, TData>({
    queryKey: queryKeyFn({
      path: "/events",
      operationId: "getEvents",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetEvents({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostEventsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostEventsVariables = {
  body: Schemas.EventRequest;
} & GubenProdContext["fetcherOptions"];

export const fetchPostEvents = (
  variables: PostEventsVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.EventResponse,
    PostEventsError,
    Schemas.EventRequest,
    {},
    {},
    {}
  >({ url: "/events", method: "post", ...variables, signal });

export const usePostEvents = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.EventResponse,
      PostEventsError,
      PostEventsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.EventResponse,
    PostEventsError,
    PostEventsVariables
  >({
    mutationFn: (variables: PostEventsVariables) =>
      fetchPostEvents({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetEventsIdPathParams = {
  id: number;
};

export type GetEventsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetEventsIdVariables = {
  pathParams: GetEventsIdPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetEventsId = (
  variables: GetEventsIdVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.EventResponse,
    GetEventsIdError,
    undefined,
    {},
    {},
    GetEventsIdPathParams
  >({ url: "/events/{id}", method: "get", ...variables, signal });

export const useGetEventsId = <TData = Schemas.EventResponse,>(
  variables: GetEventsIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.EventResponse, GetEventsIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<Schemas.EventResponse, GetEventsIdError, TData>({
    queryKey: queryKeyFn({
      path: "/events/{id}",
      operationId: "getEventsId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetEventsId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutEventsIdPathParams = {
  id: number;
};

export type PutEventsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutEventsIdVariables = {
  body: Schemas.EventRequest;
  pathParams: PutEventsIdPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchPutEventsId = (
  variables: PutEventsIdVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.EventResponse,
    PutEventsIdError,
    Schemas.EventRequest,
    {},
    {},
    PutEventsIdPathParams
  >({ url: "/events/{id}", method: "put", ...variables, signal });

export const usePutEventsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.EventResponse,
      PutEventsIdError,
      PutEventsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.EventResponse,
    PutEventsIdError,
    PutEventsIdVariables
  >({
    mutationFn: (variables: PutEventsIdVariables) =>
      fetchPutEventsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteEventsIdPathParams = {
  id: number;
};

export type DeleteEventsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteEventsIdVariables = {
  pathParams: DeleteEventsIdPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchDeleteEventsId = (
  variables: DeleteEventsIdVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    number,
    DeleteEventsIdError,
    undefined,
    {},
    {},
    DeleteEventsIdPathParams
  >({ url: "/events/{id}", method: "delete", ...variables, signal });

export const useDeleteEventsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteEventsIdError,
      DeleteEventsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    number,
    DeleteEventsIdError,
    DeleteEventsIdVariables
  >({
    mutationFn: (variables: DeleteEventsIdVariables) =>
      fetchDeleteEventsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetEventViewQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: {
    [key: string]: any;
  };
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetEventViewError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetEventViewVariables = {
  queryParams?: GetEventViewQueryParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetEventView = (
  variables: GetEventViewVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.EventViewResponse,
    GetEventViewError,
    undefined,
    {},
    GetEventViewQueryParams,
    {}
  >({ url: "/event-view", method: "get", ...variables, signal });

export const useGetEventView = <TData = Schemas.EventViewResponse,>(
  variables: GetEventViewVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.EventViewResponse,
      GetEventViewError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<
    Schemas.EventViewResponse,
    GetEventViewError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/event-view",
      operationId: "getEventView",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetEventView({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutEventViewError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutEventViewVariables = {
  body: Schemas.EventViewRequest;
} & GubenProdContext["fetcherOptions"];

export const fetchPutEventView = (
  variables: PutEventViewVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.EventViewResponse,
    PutEventViewError,
    Schemas.EventViewRequest,
    {},
    {},
    {}
  >({ url: "/event-view", method: "put", ...variables, signal });

export const usePutEventView = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.EventViewResponse,
      PutEventViewError,
      PutEventViewVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.EventViewResponse,
    PutEventViewError,
    PutEventViewVariables
  >({
    mutationFn: (variables: PutEventViewVariables) =>
      fetchPutEventView({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteEventViewError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteEventViewVariables = GubenProdContext["fetcherOptions"];

export const fetchDeleteEventView = (
  variables: DeleteEventViewVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<number, DeleteEventViewError, undefined, {}, {}, {}>({
    url: "/event-view",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteEventView = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteEventViewError,
      DeleteEventViewVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    number,
    DeleteEventViewError,
    DeleteEventViewVariables
  >({
    mutationFn: (variables: DeleteEventViewVariables) =>
      fetchDeleteEventView({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostEventViewLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostEventViewLocalizationsVariables = {
  body: Schemas.EventViewLocalizationRequest;
} & GubenProdContext["fetcherOptions"];

export const fetchPostEventViewLocalizations = (
  variables: PostEventViewLocalizationsVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.EventViewLocalizationResponse,
    PostEventViewLocalizationsError,
    Schemas.EventViewLocalizationRequest,
    {},
    {},
    {}
  >({ url: "/event-view/localizations", method: "post", ...variables, signal });

export const usePostEventViewLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.EventViewLocalizationResponse,
      PostEventViewLocalizationsError,
      PostEventViewLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.EventViewLocalizationResponse,
    PostEventViewLocalizationsError,
    PostEventViewLocalizationsVariables
  >({
    mutationFn: (variables: PostEventViewLocalizationsVariables) =>
      fetchPostEventViewLocalizations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetHomeViewQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: {
    [key: string]: any;
  };
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetHomeViewError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetHomeViewVariables = {
  queryParams?: GetHomeViewQueryParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetHomeView = (
  variables: GetHomeViewVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.HomeViewResponse,
    GetHomeViewError,
    undefined,
    {},
    GetHomeViewQueryParams,
    {}
  >({ url: "/home-view", method: "get", ...variables, signal });

export const useGetHomeView = <TData = Schemas.HomeViewResponse,>(
  variables: GetHomeViewVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.HomeViewResponse,
      GetHomeViewError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<Schemas.HomeViewResponse, GetHomeViewError, TData>(
    {
      queryKey: queryKeyFn({
        path: "/home-view",
        operationId: "getHomeView",
        variables,
      }),
      queryFn: ({ signal }) =>
        fetchGetHomeView({ ...fetcherOptions, ...variables }, signal),
      ...options,
      ...queryOptions,
    },
  );
};

export type PutHomeViewError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutHomeViewVariables = {
  body: Schemas.HomeViewRequest;
} & GubenProdContext["fetcherOptions"];

export const fetchPutHomeView = (
  variables: PutHomeViewVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.HomeViewResponse,
    PutHomeViewError,
    Schemas.HomeViewRequest,
    {},
    {},
    {}
  >({ url: "/home-view", method: "put", ...variables, signal });

export const usePutHomeView = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.HomeViewResponse,
      PutHomeViewError,
      PutHomeViewVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.HomeViewResponse,
    PutHomeViewError,
    PutHomeViewVariables
  >({
    mutationFn: (variables: PutHomeViewVariables) =>
      fetchPutHomeView({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteHomeViewError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteHomeViewVariables = GubenProdContext["fetcherOptions"];

export const fetchDeleteHomeView = (
  variables: DeleteHomeViewVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<number, DeleteHomeViewError, undefined, {}, {}, {}>({
    url: "/home-view",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteHomeView = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteHomeViewError,
      DeleteHomeViewVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    number,
    DeleteHomeViewError,
    DeleteHomeViewVariables
  >({
    mutationFn: (variables: DeleteHomeViewVariables) =>
      fetchDeleteHomeView({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostHomeViewLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostHomeViewLocalizationsVariables = {
  body: Schemas.HomeViewLocalizationRequest;
} & GubenProdContext["fetcherOptions"];

export const fetchPostHomeViewLocalizations = (
  variables: PostHomeViewLocalizationsVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.HomeViewLocalizationResponse,
    PostHomeViewLocalizationsError,
    Schemas.HomeViewLocalizationRequest,
    {},
    {},
    {}
  >({ url: "/home-view/localizations", method: "post", ...variables, signal });

export const usePostHomeViewLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.HomeViewLocalizationResponse,
      PostHomeViewLocalizationsError,
      PostHomeViewLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.HomeViewLocalizationResponse,
    PostHomeViewLocalizationsError,
    PostHomeViewLocalizationsVariables
  >({
    mutationFn: (variables: PostHomeViewLocalizationsVariables) =>
      fetchPostHomeViewLocalizations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetOverviewTabsQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: {
    [key: string]: any;
  };
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetOverviewTabsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetOverviewTabsVariables = {
  queryParams?: GetOverviewTabsQueryParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetOverviewTabs = (
  variables: GetOverviewTabsVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.OverviewTabListResponse,
    GetOverviewTabsError,
    undefined,
    {},
    GetOverviewTabsQueryParams,
    {}
  >({ url: "/overview-tabs", method: "get", ...variables, signal });

export const useGetOverviewTabs = <TData = Schemas.OverviewTabListResponse,>(
  variables: GetOverviewTabsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.OverviewTabListResponse,
      GetOverviewTabsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<
    Schemas.OverviewTabListResponse,
    GetOverviewTabsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/overview-tabs",
      operationId: "getOverviewTabs",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetOverviewTabs({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostOverviewTabsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostOverviewTabsVariables = {
  body: Schemas.OverviewTabRequest;
} & GubenProdContext["fetcherOptions"];

export const fetchPostOverviewTabs = (
  variables: PostOverviewTabsVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.OverviewTabResponse,
    PostOverviewTabsError,
    Schemas.OverviewTabRequest,
    {},
    {},
    {}
  >({ url: "/overview-tabs", method: "post", ...variables, signal });

export const usePostOverviewTabs = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.OverviewTabResponse,
      PostOverviewTabsError,
      PostOverviewTabsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.OverviewTabResponse,
    PostOverviewTabsError,
    PostOverviewTabsVariables
  >({
    mutationFn: (variables: PostOverviewTabsVariables) =>
      fetchPostOverviewTabs({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetOverviewTabsIdPathParams = {
  id: number;
};

export type GetOverviewTabsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetOverviewTabsIdVariables = {
  pathParams: GetOverviewTabsIdPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetOverviewTabsId = (
  variables: GetOverviewTabsIdVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.OverviewTabResponse,
    GetOverviewTabsIdError,
    undefined,
    {},
    {},
    GetOverviewTabsIdPathParams
  >({ url: "/overview-tabs/{id}", method: "get", ...variables, signal });

export const useGetOverviewTabsId = <TData = Schemas.OverviewTabResponse,>(
  variables: GetOverviewTabsIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.OverviewTabResponse,
      GetOverviewTabsIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<
    Schemas.OverviewTabResponse,
    GetOverviewTabsIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/overview-tabs/{id}",
      operationId: "getOverviewTabsId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetOverviewTabsId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutOverviewTabsIdPathParams = {
  id: number;
};

export type PutOverviewTabsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutOverviewTabsIdVariables = {
  body: Schemas.OverviewTabRequest;
  pathParams: PutOverviewTabsIdPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchPutOverviewTabsId = (
  variables: PutOverviewTabsIdVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.OverviewTabResponse,
    PutOverviewTabsIdError,
    Schemas.OverviewTabRequest,
    {},
    {},
    PutOverviewTabsIdPathParams
  >({ url: "/overview-tabs/{id}", method: "put", ...variables, signal });

export const usePutOverviewTabsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.OverviewTabResponse,
      PutOverviewTabsIdError,
      PutOverviewTabsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.OverviewTabResponse,
    PutOverviewTabsIdError,
    PutOverviewTabsIdVariables
  >({
    mutationFn: (variables: PutOverviewTabsIdVariables) =>
      fetchPutOverviewTabsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteOverviewTabsIdPathParams = {
  id: number;
};

export type DeleteOverviewTabsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteOverviewTabsIdVariables = {
  pathParams: DeleteOverviewTabsIdPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchDeleteOverviewTabsId = (
  variables: DeleteOverviewTabsIdVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    number,
    DeleteOverviewTabsIdError,
    undefined,
    {},
    {},
    DeleteOverviewTabsIdPathParams
  >({ url: "/overview-tabs/{id}", method: "delete", ...variables, signal });

export const useDeleteOverviewTabsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteOverviewTabsIdError,
      DeleteOverviewTabsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    number,
    DeleteOverviewTabsIdError,
    DeleteOverviewTabsIdVariables
  >({
    mutationFn: (variables: DeleteOverviewTabsIdVariables) =>
      fetchDeleteOverviewTabsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostOverviewTabsIdLocalizationsPathParams = {
  id: number;
};

export type PostOverviewTabsIdLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostOverviewTabsIdLocalizationsVariables = {
  body: Schemas.OverviewTabLocalizationRequest;
  pathParams: PostOverviewTabsIdLocalizationsPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchPostOverviewTabsIdLocalizations = (
  variables: PostOverviewTabsIdLocalizationsVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.OverviewTabLocalizationResponse,
    PostOverviewTabsIdLocalizationsError,
    Schemas.OverviewTabLocalizationRequest,
    {},
    {},
    PostOverviewTabsIdLocalizationsPathParams
  >({
    url: "/overview-tabs/{id}/localizations",
    method: "post",
    ...variables,
    signal,
  });

export const usePostOverviewTabsIdLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.OverviewTabLocalizationResponse,
      PostOverviewTabsIdLocalizationsError,
      PostOverviewTabsIdLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.OverviewTabLocalizationResponse,
    PostOverviewTabsIdLocalizationsError,
    PostOverviewTabsIdLocalizationsVariables
  >({
    mutationFn: (variables: PostOverviewTabsIdLocalizationsVariables) =>
      fetchPostOverviewTabsIdLocalizations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetProjectsQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: {
    [key: string]: any;
  };
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetProjectsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetProjectsVariables = {
  queryParams?: GetProjectsQueryParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetProjects = (
  variables: GetProjectsVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.ProjectListResponse,
    GetProjectsError,
    undefined,
    {},
    GetProjectsQueryParams,
    {}
  >({ url: "/projects", method: "get", ...variables, signal });

export const useGetProjects = <TData = Schemas.ProjectListResponse,>(
  variables: GetProjectsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ProjectListResponse,
      GetProjectsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<
    Schemas.ProjectListResponse,
    GetProjectsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/projects",
      operationId: "getProjects",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetProjects({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostProjectsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostProjectsVariables = {
  body: Schemas.ProjectRequest;
} & GubenProdContext["fetcherOptions"];

export const fetchPostProjects = (
  variables: PostProjectsVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.ProjectResponse,
    PostProjectsError,
    Schemas.ProjectRequest,
    {},
    {},
    {}
  >({ url: "/projects", method: "post", ...variables, signal });

export const usePostProjects = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ProjectResponse,
      PostProjectsError,
      PostProjectsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.ProjectResponse,
    PostProjectsError,
    PostProjectsVariables
  >({
    mutationFn: (variables: PostProjectsVariables) =>
      fetchPostProjects({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetProjectsIdPathParams = {
  id: number;
};

export type GetProjectsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetProjectsIdVariables = {
  pathParams: GetProjectsIdPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetProjectsId = (
  variables: GetProjectsIdVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.ProjectResponse,
    GetProjectsIdError,
    undefined,
    {},
    {},
    GetProjectsIdPathParams
  >({ url: "/projects/{id}", method: "get", ...variables, signal });

export const useGetProjectsId = <TData = Schemas.ProjectResponse,>(
  variables: GetProjectsIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ProjectResponse,
      GetProjectsIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<
    Schemas.ProjectResponse,
    GetProjectsIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/projects/{id}",
      operationId: "getProjectsId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetProjectsId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutProjectsIdPathParams = {
  id: number;
};

export type PutProjectsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutProjectsIdVariables = {
  body: Schemas.ProjectRequest;
  pathParams: PutProjectsIdPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchPutProjectsId = (
  variables: PutProjectsIdVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.ProjectResponse,
    PutProjectsIdError,
    Schemas.ProjectRequest,
    {},
    {},
    PutProjectsIdPathParams
  >({ url: "/projects/{id}", method: "put", ...variables, signal });

export const usePutProjectsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ProjectResponse,
      PutProjectsIdError,
      PutProjectsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.ProjectResponse,
    PutProjectsIdError,
    PutProjectsIdVariables
  >({
    mutationFn: (variables: PutProjectsIdVariables) =>
      fetchPutProjectsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteProjectsIdPathParams = {
  id: number;
};

export type DeleteProjectsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteProjectsIdVariables = {
  pathParams: DeleteProjectsIdPathParams;
} & GubenProdContext["fetcherOptions"];

export const fetchDeleteProjectsId = (
  variables: DeleteProjectsIdVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    number,
    DeleteProjectsIdError,
    undefined,
    {},
    {},
    DeleteProjectsIdPathParams
  >({ url: "/projects/{id}", method: "delete", ...variables, signal });

export const useDeleteProjectsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteProjectsIdError,
      DeleteProjectsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    number,
    DeleteProjectsIdError,
    DeleteProjectsIdVariables
  >({
    mutationFn: (variables: DeleteProjectsIdVariables) =>
      fetchDeleteProjectsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetProjectViewQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: {
    [key: string]: any;
  };
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetProjectViewError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetProjectViewVariables = {
  queryParams?: GetProjectViewQueryParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetProjectView = (
  variables: GetProjectViewVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.ProjectViewResponse,
    GetProjectViewError,
    undefined,
    {},
    GetProjectViewQueryParams,
    {}
  >({ url: "/project-view", method: "get", ...variables, signal });

export const useGetProjectView = <TData = Schemas.ProjectViewResponse,>(
  variables: GetProjectViewVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ProjectViewResponse,
      GetProjectViewError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<
    Schemas.ProjectViewResponse,
    GetProjectViewError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/project-view",
      operationId: "getProjectView",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetProjectView({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutProjectViewError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutProjectViewVariables = {
  body: Schemas.ProjectViewRequest;
} & GubenProdContext["fetcherOptions"];

export const fetchPutProjectView = (
  variables: PutProjectViewVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.ProjectViewResponse,
    PutProjectViewError,
    Schemas.ProjectViewRequest,
    {},
    {},
    {}
  >({ url: "/project-view", method: "put", ...variables, signal });

export const usePutProjectView = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ProjectViewResponse,
      PutProjectViewError,
      PutProjectViewVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.ProjectViewResponse,
    PutProjectViewError,
    PutProjectViewVariables
  >({
    mutationFn: (variables: PutProjectViewVariables) =>
      fetchPutProjectView({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteProjectViewError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteProjectViewVariables = GubenProdContext["fetcherOptions"];

export const fetchDeleteProjectView = (
  variables: DeleteProjectViewVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<number, DeleteProjectViewError, undefined, {}, {}, {}>({
    url: "/project-view",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteProjectView = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteProjectViewError,
      DeleteProjectViewVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    number,
    DeleteProjectViewError,
    DeleteProjectViewVariables
  >({
    mutationFn: (variables: DeleteProjectViewVariables) =>
      fetchDeleteProjectView({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostProjectViewLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostProjectViewLocalizationsVariables = {
  body: Schemas.ProjectViewLocalizationRequest;
} & GubenProdContext["fetcherOptions"];

export const fetchPostProjectViewLocalizations = (
  variables: PostProjectViewLocalizationsVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.ProjectViewLocalizationResponse,
    PostProjectViewLocalizationsError,
    Schemas.ProjectViewLocalizationRequest,
    {},
    {},
    {}
  >({
    url: "/project-view/localizations",
    method: "post",
    ...variables,
    signal,
  });

export const usePostProjectViewLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ProjectViewLocalizationResponse,
      PostProjectViewLocalizationsError,
      PostProjectViewLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.ProjectViewLocalizationResponse,
    PostProjectViewLocalizationsError,
    PostProjectViewLocalizationsVariables
  >({
    mutationFn: (variables: PostProjectViewLocalizationsVariables) =>
      fetchPostProjectViewLocalizations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetServiceQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: {
    [key: string]: any;
  };
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetServiceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetServiceVariables = {
  queryParams?: GetServiceQueryParams;
} & GubenProdContext["fetcherOptions"];

export const fetchGetService = (
  variables: GetServiceVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.ServiceResponse,
    GetServiceError,
    undefined,
    {},
    GetServiceQueryParams,
    {}
  >({ url: "/service", method: "get", ...variables, signal });

export const useGetService = <TData = Schemas.ServiceResponse,>(
  variables: GetServiceVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ServiceResponse, GetServiceError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGubenProdContext(options);
  return reactQuery.useQuery<Schemas.ServiceResponse, GetServiceError, TData>({
    queryKey: queryKeyFn({
      path: "/service",
      operationId: "getService",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetService({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutServiceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutServiceVariables = {
  body: Schemas.ServiceRequest;
} & GubenProdContext["fetcherOptions"];

export const fetchPutService = (
  variables: PutServiceVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<
    Schemas.ServiceResponse,
    PutServiceError,
    Schemas.ServiceRequest,
    {},
    {},
    {}
  >({ url: "/service", method: "put", ...variables, signal });

export const usePutService = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ServiceResponse,
      PutServiceError,
      PutServiceVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    Schemas.ServiceResponse,
    PutServiceError,
    PutServiceVariables
  >({
    mutationFn: (variables: PutServiceVariables) =>
      fetchPutService({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteServiceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteServiceVariables = GubenProdContext["fetcherOptions"];

export const fetchDeleteService = (
  variables: DeleteServiceVariables,
  signal?: AbortSignal,
) =>
  gubenProdFetch<number, DeleteServiceError, undefined, {}, {}, {}>({
    url: "/service",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteService = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteServiceError,
      DeleteServiceVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenProdContext();
  return reactQuery.useMutation<
    number,
    DeleteServiceError,
    DeleteServiceVariables
  >({
    mutationFn: (variables: DeleteServiceVariables) =>
      fetchDeleteService({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/categories";
      operationId: "getCategories";
      variables: GetCategoriesVariables;
    }
  | {
      path: "/categories/{id}";
      operationId: "getCategoriesId";
      variables: GetCategoriesIdVariables;
    }
  | {
      path: "/config";
      operationId: "getConfig";
      variables: GetConfigVariables;
    }
  | {
      path: "/events";
      operationId: "getEvents";
      variables: GetEventsVariables;
    }
  | {
      path: "/events/{id}";
      operationId: "getEventsId";
      variables: GetEventsIdVariables;
    }
  | {
      path: "/event-view";
      operationId: "getEventView";
      variables: GetEventViewVariables;
    }
  | {
      path: "/home-view";
      operationId: "getHomeView";
      variables: GetHomeViewVariables;
    }
  | {
      path: "/overview-tabs";
      operationId: "getOverviewTabs";
      variables: GetOverviewTabsVariables;
    }
  | {
      path: "/overview-tabs/{id}";
      operationId: "getOverviewTabsId";
      variables: GetOverviewTabsIdVariables;
    }
  | {
      path: "/projects";
      operationId: "getProjects";
      variables: GetProjectsVariables;
    }
  | {
      path: "/projects/{id}";
      operationId: "getProjectsId";
      variables: GetProjectsIdVariables;
    }
  | {
      path: "/project-view";
      operationId: "getProjectView";
      variables: GetProjectViewVariables;
    }
  | {
      path: "/service";
      operationId: "getService";
      variables: GetServiceVariables;
    };
