/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useGubenContext, GubenContext } from "./gubenContext";
import type * as Fetcher from "./gubenFetcher";
import { gubenFetch } from "./gubenFetcher";
import type * as Schemas from "./gubenSchemas";

export type UsersGetAllQueryParams = {
  /**
   * @format int32
   * @default 1
   */
  pageNumber?: number;
  /**
   * @format int32
   * @default 2
   */
  pageSize?: number;
};

export type UsersGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type UsersGetAllVariables = {
  queryParams?: UsersGetAllQueryParams;
} & GubenContext["fetcherOptions"];

export const fetchUsersGetAll = (
  variables: UsersGetAllVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetAllUsersResponse,
    UsersGetAllError,
    undefined,
    {},
    UsersGetAllQueryParams,
    {}
  >({ url: "/users", method: "get", ...variables, signal });

export const useUsersGetAll = <TData = Schemas.GetAllUsersResponse,>(
  variables: UsersGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllUsersResponse,
      UsersGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllUsersResponse,
    UsersGetAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users",
      operationId: "usersGetAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchUsersGetAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UsersGetPathParams = {
  keycloakId: string;
};

export type UsersGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type UsersGetVariables = {
  pathParams: UsersGetPathParams;
} & GubenContext["fetcherOptions"];

export const fetchUsersGet = (
  variables: UsersGetVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.UserResponse,
    UsersGetError,
    undefined,
    {},
    {},
    UsersGetPathParams
  >({ url: "/users/{keycloakId}", method: "get", ...variables, signal });

export const useUsersGet = <TData = Schemas.UserResponse,>(
  variables: UsersGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserResponse, UsersGetError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<Schemas.UserResponse, UsersGetError, TData>({
    queryKey: queryKeyFn({
      path: "/users/{keycloakId}",
      operationId: "usersGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchUsersGet({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UsersGetMeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type UsersGetMeVariables = GubenContext["fetcherOptions"];

export const fetchUsersGetMe = (
  variables: UsersGetMeVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<Schemas.UserResponse, UsersGetMeError, undefined, {}, {}, {}>({
    url: "/users/me",
    method: "get",
    ...variables,
    signal,
  });

export const useUsersGetMe = <TData = Schemas.UserResponse,>(
  variables: UsersGetMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserResponse, UsersGetMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<Schemas.UserResponse, UsersGetMeError, TData>({
    queryKey: queryKeyFn({
      path: "/users/me",
      operationId: "usersGetMe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchUsersGetMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ProjectsGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type ProjectsGetAllVariables = GubenContext["fetcherOptions"];

export const fetchProjectsGetAll = (
  variables: ProjectsGetAllVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetAllProjectsResponse,
    ProjectsGetAllError,
    undefined,
    {},
    {},
    {}
  >({ url: "/projects", method: "get", ...variables, signal });

export const useProjectsGetAll = <TData = Schemas.GetAllProjectsResponse,>(
  variables: ProjectsGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllProjectsResponse,
      ProjectsGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllProjectsResponse,
    ProjectsGetAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/projects",
      operationId: "projectsGetAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchProjectsGetAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ProjectsCreateProjectError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type ProjectsCreateProjectVariables = {
  body: Schemas.CreateProjectQuery;
} & GubenContext["fetcherOptions"];

export const fetchProjectsCreateProject = (
  variables: ProjectsCreateProjectVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.CreateProjectResponse,
    ProjectsCreateProjectError,
    Schemas.CreateProjectQuery,
    {},
    {},
    {}
  >({ url: "/projects", method: "post", ...variables, signal });

export const useProjectsCreateProject = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CreateProjectResponse,
      ProjectsCreateProjectError,
      ProjectsCreateProjectVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.CreateProjectResponse,
    ProjectsCreateProjectError,
    ProjectsCreateProjectVariables
  >({
    mutationFn: (variables: ProjectsCreateProjectVariables) =>
      fetchProjectsCreateProject({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ProjectsGetMyProjectsQueryParams = {
  /**
   * @format int32
   */
  pageNumber?: number;
  /**
   * @format int32
   */
  pageSize?: number;
};

export type ProjectsGetMyProjectsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type ProjectsGetMyProjectsVariables = {
  queryParams?: ProjectsGetMyProjectsQueryParams;
} & GubenContext["fetcherOptions"];

export const fetchProjectsGetMyProjects = (
  variables: ProjectsGetMyProjectsVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetMyProjectsResponse,
    ProjectsGetMyProjectsError,
    undefined,
    {},
    ProjectsGetMyProjectsQueryParams,
    {}
  >({ url: "/projects/owned", method: "get", ...variables, signal });

export const useProjectsGetMyProjects = <
  TData = Schemas.GetMyProjectsResponse,
>(
  variables: ProjectsGetMyProjectsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetMyProjectsResponse,
      ProjectsGetMyProjectsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetMyProjectsResponse,
    ProjectsGetMyProjectsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/projects/owned",
      operationId: "projectsGetMyProjects",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchProjectsGetMyProjects({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ProjectsPublishProjectsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type ProjectsPublishProjectsVariables = {
  body: Schemas.PublishProjectsQuery;
} & GubenContext["fetcherOptions"];

export const fetchProjectsPublishProjects = (
  variables: ProjectsPublishProjectsVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.PublishProjectsResponse,
    ProjectsPublishProjectsError,
    Schemas.PublishProjectsQuery,
    {},
    {},
    {}
  >({ url: "/projects/Publish", method: "put", ...variables, signal });

export const useProjectsPublishProjects = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PublishProjectsResponse,
      ProjectsPublishProjectsError,
      ProjectsPublishProjectsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.PublishProjectsResponse,
    ProjectsPublishProjectsError,
    ProjectsPublishProjectsVariables
  >({
    mutationFn: (variables: ProjectsPublishProjectsVariables) =>
      fetchProjectsPublishProjects({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ProjectsUpdateProjectPathParams = {
  id: string;
};

export type ProjectsUpdateProjectError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type ProjectsUpdateProjectVariables = {
  body: Schemas.UpdateProjectQuery;
  pathParams: ProjectsUpdateProjectPathParams;
} & GubenContext["fetcherOptions"];

export const fetchProjectsUpdateProject = (
  variables: ProjectsUpdateProjectVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.CreateProjectResponse,
    ProjectsUpdateProjectError,
    Schemas.UpdateProjectQuery,
    {},
    {},
    ProjectsUpdateProjectPathParams
  >({ url: "/projects/{id}", method: "put", ...variables, signal });

export const useProjectsUpdateProject = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CreateProjectResponse,
      ProjectsUpdateProjectError,
      ProjectsUpdateProjectVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.CreateProjectResponse,
    ProjectsUpdateProjectError,
    ProjectsUpdateProjectVariables
  >({
    mutationFn: (variables: ProjectsUpdateProjectVariables) =>
      fetchProjectsUpdateProject({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PagesGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type PagesGetAllVariables = GubenContext["fetcherOptions"];

export const fetchPagesGetAll = (
  variables: PagesGetAllVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetAllEventsResponse,
    PagesGetAllError,
    undefined,
    {},
    {},
    {}
  >({ url: "/pages", method: "get", ...variables, signal });

export const usePagesGetAll = <TData = Schemas.GetAllEventsResponse,>(
  variables: PagesGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllEventsResponse,
      PagesGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllEventsResponse,
    PagesGetAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/pages",
      operationId: "pagesGetAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchPagesGetAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PagesGetPathParams = {
  id: string;
};

export type PagesGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type PagesGetVariables = {
  pathParams: PagesGetPathParams;
} & GubenContext["fetcherOptions"];

export const fetchPagesGet = (
  variables: PagesGetVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.PageResponse,
    PagesGetError,
    undefined,
    {},
    {},
    PagesGetPathParams
  >({ url: "/pages/${id}", method: "get", ...variables, signal });

export const usePagesGet = <TData = Schemas.PageResponse,>(
  variables: PagesGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.PageResponse, PagesGetError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<Schemas.PageResponse, PagesGetError, TData>({
    queryKey: queryKeyFn({
      path: "/pages/${id}",
      operationId: "pagesGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchPagesGet({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PagesUpdatePathParams = {
  id: string;
};

export type PagesUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type PagesUpdateVariables = {
  body: Schemas.UpdatePageQuery;
  pathParams: PagesUpdatePathParams;
} & GubenContext["fetcherOptions"];

export const fetchPagesUpdate = (
  variables: PagesUpdateVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.UpdatePageResponse,
    PagesUpdateError,
    Schemas.UpdatePageQuery,
    {},
    {},
    PagesUpdatePathParams
  >({ url: "/pages/${id}", method: "put", ...variables, signal });

export const usePagesUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UpdatePageResponse,
      PagesUpdateError,
      PagesUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.UpdatePageResponse,
    PagesUpdateError,
    PagesUpdateVariables
  >({
    mutationFn: (variables: PagesUpdateVariables) =>
      fetchPagesUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LocationsGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type LocationsGetAllVariables = GubenContext["fetcherOptions"];

export const fetchLocationsGetAll = (
  variables: LocationsGetAllVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetAllLocationsResponse,
    LocationsGetAllError,
    undefined,
    {},
    {},
    {}
  >({ url: "/locations", method: "get", ...variables, signal });

export const useLocationsGetAll = <TData = Schemas.GetAllLocationsResponse,>(
  variables: LocationsGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllLocationsResponse,
      LocationsGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllLocationsResponse,
    LocationsGetAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/locations",
      operationId: "locationsGetAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchLocationsGetAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type EventsGetAllQueryParams = {
  title?: string;
  location?: string;
  /**
   * @format uuid
   */
  category?: string;
  /**
   * @format date
   */
  startDate?: string;
  /**
   * @format date
   */
  endDate?: string;
  sortBy?: string;
  ordering?: string;
  /**
   * @format int32
   */
  pageNumber?: number;
  /**
   * @format int32
   */
  pageSize?: number;
};

export type EventsGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type EventsGetAllVariables = {
  queryParams?: EventsGetAllQueryParams;
} & GubenContext["fetcherOptions"];

export const fetchEventsGetAll = (
  variables: EventsGetAllVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetAllEventsResponse,
    EventsGetAllError,
    undefined,
    {},
    EventsGetAllQueryParams,
    {}
  >({ url: "/events", method: "get", ...variables, signal });

export const useEventsGetAll = <TData = Schemas.GetAllEventsResponse,>(
  variables: EventsGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllEventsResponse,
      EventsGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllEventsResponse,
    EventsGetAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/events",
      operationId: "eventsGetAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchEventsGetAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type EventsCreateEventError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type EventsCreateEventVariables = {
  body: Schemas.CreateEventQuery;
} & GubenContext["fetcherOptions"];

export const fetchEventsCreateEvent = (
  variables: EventsCreateEventVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.CreateEventResponse,
    EventsCreateEventError,
    Schemas.CreateEventQuery,
    {},
    {},
    {}
  >({ url: "/events", method: "post", ...variables, signal });

export const useEventsCreateEvent = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CreateEventResponse,
      EventsCreateEventError,
      EventsCreateEventVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.CreateEventResponse,
    EventsCreateEventError,
    EventsCreateEventVariables
  >({
    mutationFn: (variables: EventsCreateEventVariables) =>
      fetchEventsCreateEvent({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DashboardGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type DashboardGetAllVariables = GubenContext["fetcherOptions"];

export const fetchDashboardGetAll = (
  variables: DashboardGetAllVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetAllDashboardTabsResponse,
    DashboardGetAllError,
    undefined,
    {},
    {},
    {}
  >({ url: "/dashboard", method: "get", ...variables, signal });

export const useDashboardGetAll = <
  TData = Schemas.GetAllDashboardTabsResponse,
>(
  variables: DashboardGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllDashboardTabsResponse,
      DashboardGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllDashboardTabsResponse,
    DashboardGetAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/dashboard",
      operationId: "dashboardGetAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchDashboardGetAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type DashboardUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type DashboardUpdateVariables = {
  body: Schemas.UpdateDashboardTabQuery;
} & GubenContext["fetcherOptions"];

export const fetchDashboardUpdate = (
  variables: DashboardUpdateVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.UpdateDashboardTabResponse,
    DashboardUpdateError,
    Schemas.UpdateDashboardTabQuery,
    {},
    {},
    {}
  >({ url: "/dashboard", method: "put", ...variables, signal });

export const useDashboardUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UpdateDashboardTabResponse,
      DashboardUpdateError,
      DashboardUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.UpdateDashboardTabResponse,
    DashboardUpdateError,
    DashboardUpdateVariables
  >({
    mutationFn: (variables: DashboardUpdateVariables) =>
      fetchDashboardUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DashboardCreateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type DashboardCreateVariables = {
  body: Schemas.CreateDashboardTabQuery;
} & GubenContext["fetcherOptions"];

export const fetchDashboardCreate = (
  variables: DashboardCreateVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.CreateDashboardTabResponse,
    DashboardCreateError,
    Schemas.CreateDashboardTabQuery,
    {},
    {},
    {}
  >({ url: "/dashboard", method: "post", ...variables, signal });

export const useDashboardCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CreateDashboardTabResponse,
      DashboardCreateError,
      DashboardCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.CreateDashboardTabResponse,
    DashboardCreateError,
    DashboardCreateVariables
  >({
    mutationFn: (variables: DashboardCreateVariables) =>
      fetchDashboardCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DashboardDeletePathParams = {
  /**
   * @format uuid
   */
  id: string;
};

export type DashboardDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type DashboardDeleteVariables = {
  pathParams: DashboardDeletePathParams;
} & GubenContext["fetcherOptions"];

export const fetchDashboardDelete = (
  variables: DashboardDeleteVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.DeleteDashboardTabResponse,
    DashboardDeleteError,
    undefined,
    {},
    {},
    DashboardDeletePathParams
  >({ url: "/dashboard/{id}", method: "delete", ...variables, signal });

export const useDashboardDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.DeleteDashboardTabResponse,
      DashboardDeleteError,
      DashboardDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.DeleteDashboardTabResponse,
    DashboardDeleteError,
    DashboardDeleteVariables
  >({
    mutationFn: (variables: DashboardDeleteVariables) =>
      fetchDashboardDelete({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DashboardCreateCardPathParams = {
  /**
   * @format uuid
   */
  id: string;
};

export type DashboardCreateCardError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type DashboardCreateCardVariables = {
  body: Schemas.AddCardToTabQuery;
  pathParams: DashboardCreateCardPathParams;
} & GubenContext["fetcherOptions"];

export const fetchDashboardCreateCard = (
  variables: DashboardCreateCardVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.AddCardToTabResponse,
    DashboardCreateCardError,
    Schemas.AddCardToTabQuery,
    {},
    {},
    DashboardCreateCardPathParams
  >({ url: "/dashboard/{id}/card", method: "post", ...variables, signal });

export const useDashboardCreateCard = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AddCardToTabResponse,
      DashboardCreateCardError,
      DashboardCreateCardVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.AddCardToTabResponse,
    DashboardCreateCardError,
    DashboardCreateCardVariables
  >({
    mutationFn: (variables: DashboardCreateCardVariables) =>
      fetchDashboardCreateCard({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DashboardCardUpdatePathParams = {
  /**
   * @format uuid
   */
  id: string;
  /**
   * @format uuid
   */
  cardId: string;
};

export type DashboardCardUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type DashboardCardUpdateVariables = {
  body: Schemas.UpdateCardOnTabQuery;
  pathParams: DashboardCardUpdatePathParams;
} & GubenContext["fetcherOptions"];

export const fetchDashboardCardUpdate = (
  variables: DashboardCardUpdateVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.UpdateCardOnTabResponse,
    DashboardCardUpdateError,
    Schemas.UpdateCardOnTabQuery,
    {},
    {},
    DashboardCardUpdatePathParams
  >({
    url: "/dashboard/{id}/card/{cardId}",
    method: "put",
    ...variables,
    signal,
  });

export const useDashboardCardUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UpdateCardOnTabResponse,
      DashboardCardUpdateError,
      DashboardCardUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.UpdateCardOnTabResponse,
    DashboardCardUpdateError,
    DashboardCardUpdateVariables
  >({
    mutationFn: (variables: DashboardCardUpdateVariables) =>
      fetchDashboardCardUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DashboardCardDeletePathParams = {
  /**
   * @format uuid
   */
  id: string;
  /**
   * @format uuid
   */
  cardId: string;
};

export type DashboardCardDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type DashboardCardDeleteVariables = {
  pathParams: DashboardCardDeletePathParams;
} & GubenContext["fetcherOptions"];

export const fetchDashboardCardDelete = (
  variables: DashboardCardDeleteVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.DeleteCardFromTabResponse,
    DashboardCardDeleteError,
    undefined,
    {},
    {},
    DashboardCardDeletePathParams
  >({
    url: "/dashboard/{id}/card/{cardId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDashboardCardDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.DeleteCardFromTabResponse,
      DashboardCardDeleteError,
      DashboardCardDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.DeleteCardFromTabResponse,
    DashboardCardDeleteError,
    DashboardCardDeleteVariables
  >({
    mutationFn: (variables: DashboardCardDeleteVariables) =>
      fetchDashboardCardDelete({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type CategoriesGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type CategoriesGetAllVariables = GubenContext["fetcherOptions"];

export const fetchCategoriesGetAll = (
  variables: CategoriesGetAllVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetAllCategoriesResponse,
    CategoriesGetAllError,
    undefined,
    {},
    {},
    {}
  >({ url: "/categories", method: "get", ...variables, signal });

export const useCategoriesGetAll = <TData = Schemas.GetAllCategoriesResponse,>(
  variables: CategoriesGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllCategoriesResponse,
      CategoriesGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllCategoriesResponse,
    CategoriesGetAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/categories",
      operationId: "categoriesGetAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchCategoriesGetAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/users";
      operationId: "usersGetAll";
      variables: UsersGetAllVariables;
    }
  | {
      path: "/users/{keycloakId}";
      operationId: "usersGet";
      variables: UsersGetVariables;
    }
  | {
      path: "/users/me";
      operationId: "usersGetMe";
      variables: UsersGetMeVariables;
    }
  | {
      path: "/projects";
      operationId: "projectsGetAll";
      variables: ProjectsGetAllVariables;
    }
  | {
      path: "/projects/owned";
      operationId: "projectsGetMyProjects";
      variables: ProjectsGetMyProjectsVariables;
    }
  | {
      path: "/pages";
      operationId: "pagesGetAll";
      variables: PagesGetAllVariables;
    }
  | {
      path: "/pages/${id}";
      operationId: "pagesGet";
      variables: PagesGetVariables;
    }
  | {
      path: "/locations";
      operationId: "locationsGetAll";
      variables: LocationsGetAllVariables;
    }
  | {
      path: "/events";
      operationId: "eventsGetAll";
      variables: EventsGetAllVariables;
    }
  | {
      path: "/dashboard";
      operationId: "dashboardGetAll";
      variables: DashboardGetAllVariables;
    }
  | {
      path: "/categories";
      operationId: "categoriesGetAll";
      variables: CategoriesGetAllVariables;
    };
