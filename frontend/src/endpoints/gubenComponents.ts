/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useGubenContext, GubenContext } from "./gubenContext";
import type * as Fetcher from "./gubenFetcher";
import { gubenFetch } from "./gubenFetcher";
import type * as Schemas from "./gubenSchemas";

export type UsersGetAllQueryParams = {
  /**
   * @format int32
   * @default 1
   */
  pageNumber?: number;
  /**
   * @format int32
   * @default 2
   */
  pageSize?: number;
};

export type UsersGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type UsersGetAllVariables = {
  queryParams?: UsersGetAllQueryParams;
} & GubenContext["fetcherOptions"];

export const fetchUsersGetAll = (
  variables: UsersGetAllVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetAllUsersResponse,
    UsersGetAllError,
    undefined,
    {},
    UsersGetAllQueryParams,
    {}
  >({ url: "/users", method: "get", ...variables, signal });

export const useUsersGetAll = <TData = Schemas.GetAllUsersResponse,>(
  variables: UsersGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllUsersResponse,
      UsersGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllUsersResponse,
    UsersGetAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users",
      operationId: "usersGetAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchUsersGetAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UsersGetPathParams = {
  keycloakId: string;
};

export type UsersGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type UsersGetVariables = {
  pathParams: UsersGetPathParams;
} & GubenContext["fetcherOptions"];

export const fetchUsersGet = (
  variables: UsersGetVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetUserResponse,
    UsersGetError,
    undefined,
    {},
    {},
    UsersGetPathParams
  >({ url: "/users/{keycloakId}", method: "get", ...variables, signal });

export const useUsersGet = <TData = Schemas.GetUserResponse,>(
  variables: UsersGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.GetUserResponse, UsersGetError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<Schemas.GetUserResponse, UsersGetError, TData>({
    queryKey: queryKeyFn({
      path: "/users/{keycloakId}",
      operationId: "usersGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchUsersGet({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UsersGetMeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type UsersGetMeVariables = GubenContext["fetcherOptions"];

export const fetchUsersGetMe = (
  variables: UsersGetMeVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<Schemas.GetMeResponse, UsersGetMeError, undefined, {}, {}, {}>({
    url: "/users/me",
    method: "get",
    ...variables,
    signal,
  });

export const useUsersGetMe = <TData = Schemas.GetMeResponse,>(
  variables: UsersGetMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.GetMeResponse, UsersGetMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<Schemas.GetMeResponse, UsersGetMeError, TData>({
    queryKey: queryKeyFn({
      path: "/users/me",
      operationId: "usersGetMe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchUsersGetMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ProjectsGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type ProjectsGetAllVariables = GubenContext["fetcherOptions"];

export const fetchProjectsGetAll = (
  variables: ProjectsGetAllVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetAllProjectsResponse,
    ProjectsGetAllError,
    undefined,
    {},
    {},
    {}
  >({ url: "/projects", method: "get", ...variables, signal });

export const useProjectsGetAll = <TData = Schemas.GetAllProjectsResponse,>(
  variables: ProjectsGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllProjectsResponse,
      ProjectsGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllProjectsResponse,
    ProjectsGetAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/projects",
      operationId: "projectsGetAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchProjectsGetAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ProjectsPublishProjectsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type ProjectsPublishProjectsRequestBody = string[];

export type ProjectsPublishProjectsVariables = {
  body?: ProjectsPublishProjectsRequestBody;
} & GubenContext["fetcherOptions"];

export const fetchProjectsPublishProjects = (
  variables: ProjectsPublishProjectsVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.PublishProjectsResponse,
    ProjectsPublishProjectsError,
    ProjectsPublishProjectsRequestBody,
    {},
    {},
    {}
  >({ url: "/projects/Publish", method: "put", ...variables, signal });

export const useProjectsPublishProjects = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PublishProjectsResponse,
      ProjectsPublishProjectsError,
      ProjectsPublishProjectsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.PublishProjectsResponse,
    ProjectsPublishProjectsError,
    ProjectsPublishProjectsVariables
  >({
    mutationFn: (variables: ProjectsPublishProjectsVariables) =>
      fetchProjectsPublishProjects({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ProjectsUnpublishProjectsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type ProjectsUnpublishProjectsRequestBody = string[];

export type ProjectsUnpublishProjectsVariables = {
  body?: ProjectsUnpublishProjectsRequestBody;
} & GubenContext["fetcherOptions"];

export const fetchProjectsUnpublishProjects = (
  variables: ProjectsUnpublishProjectsVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.UnpublishProjectsResponse,
    ProjectsUnpublishProjectsError,
    ProjectsUnpublishProjectsRequestBody,
    {},
    {},
    {}
  >({ url: "/projects/Unpublish", method: "put", ...variables, signal });

export const useProjectsUnpublishProjects = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UnpublishProjectsResponse,
      ProjectsUnpublishProjectsError,
      ProjectsUnpublishProjectsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.UnpublishProjectsResponse,
    ProjectsUnpublishProjectsError,
    ProjectsUnpublishProjectsVariables
  >({
    mutationFn: (variables: ProjectsUnpublishProjectsVariables) =>
      fetchProjectsUnpublishProjects({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LocationsGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type LocationsGetAllVariables = GubenContext["fetcherOptions"];

export const fetchLocationsGetAll = (
  variables: LocationsGetAllVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetAllLocationsResponse,
    LocationsGetAllError,
    undefined,
    {},
    {},
    {}
  >({ url: "/locations", method: "get", ...variables, signal });

export const useLocationsGetAll = <TData = Schemas.GetAllLocationsResponse,>(
  variables: LocationsGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllLocationsResponse,
      LocationsGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllLocationsResponse,
    LocationsGetAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/locations",
      operationId: "locationsGetAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchLocationsGetAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type EventsGetAllQueryParams = {
  title?: string;
  location?: string;
  /**
   * @format uuid
   */
  categoryId?: string;
  /**
   * @format date
   */
  startDate?: string;
  /**
   * @format date
   */
  endDate?: string;
  sortBy?: "Title" | "StartDate";
  sortDirection?: "Ascending" | "Descending";
  /**
   * @format int32
   * @default 1
   */
  pageNumber?: number;
  /**
   * @format int32
   * @default 2
   */
  pageSize?: number;
};

export type EventsGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type EventsGetAllVariables = {
  queryParams?: EventsGetAllQueryParams;
} & GubenContext["fetcherOptions"];

export const fetchEventsGetAll = (
  variables: EventsGetAllVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetAllEventsResponse,
    EventsGetAllError,
    undefined,
    {},
    EventsGetAllQueryParams,
    {}
  >({ url: "/events", method: "get", ...variables, signal });

export const useEventsGetAll = <TData = Schemas.GetAllEventsResponse,>(
  variables: EventsGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllEventsResponse,
      EventsGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllEventsResponse,
    EventsGetAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/events",
      operationId: "eventsGetAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchEventsGetAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type EventsCreateEventError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type EventsCreateEventVariables = {
  body: Schemas.CreateEventQuery;
} & GubenContext["fetcherOptions"];

export const fetchEventsCreateEvent = (
  variables: EventsCreateEventVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.CreateEventResponse,
    EventsCreateEventError,
    Schemas.CreateEventQuery,
    {},
    {},
    {}
  >({ url: "/events", method: "post", ...variables, signal });

export const useEventsCreateEvent = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CreateEventResponse,
      EventsCreateEventError,
      EventsCreateEventVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useGubenContext();
  return reactQuery.useMutation<
    Schemas.CreateEventResponse,
    EventsCreateEventError,
    EventsCreateEventVariables
  >({
    mutationFn: (variables: EventsCreateEventVariables) =>
      fetchEventsCreateEvent({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type CategoriesGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type CategoriesGetAllVariables = GubenContext["fetcherOptions"];

export const fetchCategoriesGetAll = (
  variables: CategoriesGetAllVariables,
  signal?: AbortSignal,
) =>
  gubenFetch<
    Schemas.GetAllCategoriesResponse,
    CategoriesGetAllError,
    undefined,
    {},
    {},
    {}
  >({ url: "/categories", method: "get", ...variables, signal });

export const useCategoriesGetAll = <TData = Schemas.GetAllCategoriesResponse,>(
  variables: CategoriesGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllCategoriesResponse,
      CategoriesGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useGubenContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllCategoriesResponse,
    CategoriesGetAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/categories",
      operationId: "categoriesGetAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchCategoriesGetAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/users";
      operationId: "usersGetAll";
      variables: UsersGetAllVariables;
    }
  | {
      path: "/users/{keycloakId}";
      operationId: "usersGet";
      variables: UsersGetVariables;
    }
  | {
      path: "/users/me";
      operationId: "usersGetMe";
      variables: UsersGetMeVariables;
    }
  | {
      path: "/projects";
      operationId: "projectsGetAll";
      variables: ProjectsGetAllVariables;
    }
  | {
      path: "/locations";
      operationId: "locationsGetAll";
      variables: LocationsGetAllVariables;
    }
  | {
      path: "/events";
      operationId: "eventsGetAll";
      variables: EventsGetAllVariables;
    }
  | {
      path: "/categories";
      operationId: "categoriesGetAll";
      variables: CategoriesGetAllVariables;
    };
